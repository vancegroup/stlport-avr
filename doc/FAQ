                           Content

Q1 About STLport and availability

Q1.0 What is STLport?
Q1.1 What is benefits from using STLport?
Q1.2 What versions of STLport available?

Q2 General

Q2.0 Do I need a C++ compiler?
Q2.1 Do I need runtime libraries from C++ compiler?
Q2.2 Can I use containers and algorithms from STLport and iostreams from
library that shipout with compiler?
Q2.3 Can I mix STL implementations in my project?
Q2.4 When I switch to STLport in my application, I get errors. Is STLport
so bad?

Q3 Building

Q3.0 On my XXXX Linux n.n g++ headers are in /usr/include/g++, but they
are looked for in /usr/include/3.3.1. Is it a STLport bug?
Q3.1 Do I need to build library to use STLport?
Q3.2 During library compilation with MS VC++ 6.0 I see following error report:...
Q3.3 Does anybody success in building STLport on OS Y with compiler K n.n?

Q4 Installation

Q4.1 I tried "make -f gcc.mak install", but it install nothing into
/usr/local/. How I can install headers into /usr/local/include and
libs into /usr/local/lib?

Q5 Bug report

Q5.0 I am found a bug. How I can report about it?

Q6 Design

Q6.0 In STLport present files like locale.h, setjmp.h, stdlib.h, etc.,
that do nothing except include native headers. Why this files present in STLport?
Q6.1 Is STLport a replacement for headers and libraries that shipout
with compiler?
                           Answers

========================================================================

Q1.0 What is STLport?
A1.0 STLport is implementation of C++ Standard Library, as described in
the INTERNATIONAL STANDARD ISO/IEC 14882:1998(E) and latest
ISO/IEC 14882:2003(E).

========================================================================

Q1.1 What is benefits from using STLport?

A1.1

========================================================================

Q1.2 What versions of STLport available?

A1.2

========================================================================

Q2.0 Do I need a C++ compiler?

A2.0 STLport is a C++ library. So answer is 'yes, you need'.

========================================================================

Q2.1 Do I need runtime libraries from C++ compiler?

A2.1 In any case C++ language support from compiler is required
for STLport (operators new, delete, RTTI, exceptions support). That's why
in most cases you need some runtime libraries from C++ compiler.

========================================================================

Q2.2 Can I use containers and algorithms from STLport and iostreams from
library that shipout with compiler?

A2.2 This is a case of STL implementations mix. See A2.3 below.

========================================================================

Q2.3 Can I mix STL implementations in my project?

A2.3 The short answer is 'No'.

Indeed co-existence of two implementations possible, but this required
a lot of knowledge as about both implementations, as about compiler and
linkage. This issues should be taken into account both within STL library and
during library usage. In common you can't use both implementation
in the same namespace. So you should separate STL implementations into
different namespaces. But due to absent of compilers that has full-featured
support of Argument Dependent Lookup (ADL) (aka Koenig Lookup), you has no
possibilty to select one or another implementation.

ADL problem.

In wrapper mode, all std references are replaced, thanks a simple macro,
by the stlp_std namespace. Everything from the native compiler std namespace
is injected to the stlp_std namespace with many using std::* directives.

The problem arise when you specialized a standard class for one of your
user types. You do it within the std namespace that, in wrapper mode
becomes the stlp_std namespace. Then this specialization is just invisible
from the native std namespace and won't be used.

Things are somewhat worse: the problem arises even without any explicit
specializations. It is not a bug, but the fact that old compilers just
did not tried to find functions in the namespaces where arguments' classes
are defined (indeed no compilers with full-featured support of ADL yet).

Mix imlementation via library.

Let's reduce all the complexity of STLport to some very simple example:

namespace std {

class string
{
  public:
    class iterator { };

    iterator begin();
    iterator end();
};

template<class I, class T>
void find(I begin, I end, T value);

} // namespace std


namespace stlport {

using std::string;

template<class I, class T>
void find(I begin, I end, T value);

void gee()
{
  string s;
  find(s.begin(), s.end(), 10);
}

} // namespace stlport


When a compiler supporting ADL finds the call to `find' within gee() function
it should examine both namespace `stlport' and namespace `std' for
the presence of `find'. It is caused by the fact that s.begin() returns
object of type `std::string::iterator' which obviously defined in namespace
`std' and the heart of ADL is finding functions not only within namespaces
where the call is being made but also in the namespaces where the classes
of arguments are defined...

So, in our example compiler ends with two templates satisfying the call
`find(s.begin(), s.end(), 10)': `std::find' and `stlport::find'.
Since compiler can not choose any one of them it reports ambiguity.

There is another aspect of mix implementations.
Let's consider following code:

a.h:

#include <string>

class A {
  public:
    A() {}

    void push( const string s );
    
    string _str;
};

a.cpp:

#include "a.h"

void A::push( const string s )
{
  _str = s;
}


b.cpp:

#include "a.h"

string s;
A a;

void gee()
{
   a.push( s );
}

Now build library from a.cpp with string implementation Impl1;
than build application with b.cpp that use string implementation Impl2,
and link with mentioned above library. Compiler will pass. Linker may be
pass too. But you application will crash (or randomly carash) either on
call a.push, or on assignment _str = s. This is evident here, but not
evident in real applications.

The conclusion is: "Using Wrapper mode is very hard and we remove support
for it". If you still want to play in mine picker, do it at you own risk
and don't disturb us.

========================================================================

Q2.4 When I switch to STLport in my application, I get errors. Is STLport
so bad?

A2.4 Before you post such message, please, check the STLport WHITHOUT
YOU errors:
  - build STLport library
  - build STLport unit tests
  - run STLport unit tests
If any of above steps fail, please, check you carefully follow
build instructions report (in most cases you definitely should reread
instructions and check that you correctly unpack archive in case you see
'file not found' message). Build instructions you can found in files
INSTALL, doc/README.*, build/README*, build/test/unit/README*.
If you sure, write problem description
http://www.stlport.com/cgi-bin/forum/dcboard.cgi?az=list&forum=DCForumID6&conf=DCConfID1
(for stable, fixed release) or here
http://www.stlport.com/cgi-bin/forum/dcboard.cgi?az=list&forum=DCForumID5&conf=DCConfID1
(for betas). Don't foget to describe you operational environment, compiler
version and STLport version.

========================================================================

Q3.0 On my XXXX Linux n.n g++ headers are in /usr/include/g++, but they
are looked for in /usr/include/3.3.1. Is it a STLport bug?

A3.0 Path to native compiler headers for gcc correspond to default path
after build/install compiler (i.e. pathes from compiler origo).
Package maintainers can use any path by own taste---we can't satisfy
variety of distributions/packages.

So you can:
 - fix path in stlport sources (for you own needs)
 - make request to package maintainer
 - build and install compiler

========================================================================

Q3.1 Do I need to build library to use STLport?

A3.1 You may omit usage (and, thus building) STLport library, but in this
case you can't use iostreams, locale, complex.

========================================================================

Q3.2 During library compilation with MS VC++ 6.0 I see following error report:

C:\Program Files\Microsoft SDK\Include\.\winbase.h(1123) : error C2733: second C linkage of overloaded function 'InterlockedIncrement' not allowed
        C:\Program Files\Microsoft SDK\Include\.\winbase.h(1121) : see declaration of 'InterlockedIncrement'
C:\Program Files\Microsoft SDK\Include\.\winbase.h(1130) : error C2733: second C linkage of overloaded function 'InterlockedDecrement' not allowed
        C:\Program Files\Microsoft SDK\Include\.\winbase.h(1128) : see declaration of 'InterlockedDecrement'
C:\Program Files\Microsoft SDK\Include\.\winbase.h(1138) : error C2733: second C linkage of overloaded function 'InterlockedExchange' not allowed
        C:\Program Files\Microsoft SDK\Include\.\winbase.h(1135) : see declaration of 'InterlockedExchange'

A3.2 You have SDK installed. Uncomment line
#define _STLP_NEW_PLATFORM_SDK 1
in the file stlport/stl_user_config.h. There is no way to detect SDK
presence during preprocessor stage.

========================================================================

Q3.3 Does anybody success in building STLport on OS S with compiler K n.n?

A3.3 See report about results of regression tests here: build/test/unit/STATUS.

========================================================================

Q4.1 I tried "make -f gcc.mak install", but it install nothing into
/usr/local/. How I can install headers into /usr/local/include and
libs into /usr/local/lib?

A4.1 Installation in any system-wide place is issue of either 'package builder'
or system administrator. He/she should be familiar with building package
procedure and/or understand where headers and libraries should be situated.
The place choice not issue of STLport.

You can just use

(cd ${STLPORT_SRC}/lib; tar cf - . ) | (cd ${TARGET_LIB_DIR}; tar xf - ); \
 (cd ${STLPORT_SRC}; tar cf - stlport) | (cd ${TARGET_INCLUDE_DIR}; tar xf - )

Sometimes we will think about 'make install', but not now.


========================================================================

Q5.0 I am found a bug. How I can report about it?

A5.0 
  0. Ensure that this is a really bug (standard violation, incorrect
     behaviour with correct usage);
  1. Ensure that bug is in STLport, not in your code;
  2. Write short test that demonstrate this bug;
  3. Write bug description and test here
     http://www.stlport.com/cgi-bin/forum/dcboard.cgi?az=list&forum=DCForumID6&conf=DCConfID1
     (for stable, fixed release) or here
     http://www.stlport.com/cgi-bin/forum/dcboard.cgi?az=list&forum=DCForumID5&conf=DCConfID1
     (for betas). Don't foget to describe you operational environment, compiler
     version and STLport version.

========================================================================

Q6.0 In STLport present files like locale.h, setjmp.h, stdlib.h, etc.,
that do nothing except include native headers. Why this files present in STLport?

A6.0 Sometimes native C headers was using C++ one or was refering
to the std namespace. That's why, if stddef whould absent in STLport, then

#include <string>
#include <stddef.h>

may cause problem in following code, because std redefined in the end of
<string> header, and std may be used in stddef.h:

__BEGIN_NAMESPACE_STD
....
__END_NAMESPACE_STD

where __BEGIN_NAMESPACE_STD is defined as 'namespace std {'.
To avoid this, STLport has stddef.h header and provide correct masquerade
for std.

========================================================================

Q6.1 Is STLport a replacement for headers and libraries that shipout
with compiler?

A6.1 In general no. In any case C++ language support from compiler is required
for STLport (operators new, delete, RTTI, exceptions support). STLport also
use 'native' headers and libraries to take interface to system functions and
variables.
